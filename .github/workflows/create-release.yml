# FoundryVTT Module Release Workflow
# Manual trigger only - run with: gh workflow run release.yml -f version=1.0.2

name: Create Release

"on":
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.2)'
        required: true
        type: string

env:
  MODULE_ID: simulacrum

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set version
        id: version
        run: echo "version=${{ inputs.version }}" >> $GITHUB_OUTPUT

      - name: Convert README to HTML description
        run: |
          npm install -g marked
          REPO_RAW="https://raw.githubusercontent.com/${{ github.repository }}/main"
          cat README.md | \
            sed '/^\[!\[/d' | \
            sed "s|](docs/|](${REPO_RAW}/docs/|g" | \
            sed "s|src=\"docs/|src=\"${REPO_RAW}/docs/|g" \
            > readme_processed.md
          marked readme_processed.md > readme.html
          sed -i '0,/<h1[^>]*>.*<\/h1>/s///' readme.html
          cat readme.html | tr '\n' ' ' | sed 's/  */ /g' > readme_single.html
          rm -f readme_processed.md

      - name: Update module.json version
        run: |
          VERSION=${{ steps.version.outputs.version }}
          REPO_URL="https://github.com/${{ github.repository }}"
          README_HTML=$(cat readme_single.html)
          jq --arg ver "$VERSION" \
             --arg manifest "${REPO_URL}/releases/download/${VERSION}/module.json" \
             --arg download "${REPO_URL}/releases/download/${VERSION}/${MODULE_ID}.zip" \
             --arg desc "$README_HTML" \
             '.version = $ver | .manifest = $manifest | .download = $download | .description = $desc' \
             module.json > module.json.tmp && mv module.json.tmp module.json
          echo "Updated module.json:"
          cat module.json | jq '.version, .manifest, .download'
          rm -f readme.html readme_single.html

      - name: Build compendium packs
        run: npm run build:packs

      - name: Create module zip
        run: |
          mkdir -p dist/${{ env.MODULE_ID }}
          cp -r assets dist/${{ env.MODULE_ID }}/
          cp -r lang dist/${{ env.MODULE_ID }}/
          rsync -a --exclude='_source' --exclude='_staging' packs/ dist/${{ env.MODULE_ID }}/packs/
          cp -r scripts dist/${{ env.MODULE_ID }}/
          cp -r styles dist/${{ env.MODULE_ID }}/
          cp -r templates dist/${{ env.MODULE_ID }}/
          cp module.json dist/${{ env.MODULE_ID }}/
          cp README.md dist/${{ env.MODULE_ID }}/
          cp LICENSE dist/${{ env.MODULE_ID }}/ 2>/dev/null || true
          cd dist
          zip -r ${{ env.MODULE_ID }}.zip ${{ env.MODULE_ID }}
          mv ${{ env.MODULE_ID }}.zip ../
          cp ${{ env.MODULE_ID }}/module.json ../module.json.release
          cd ..
          mv module.json.release module.json

      - name: Generate changelog
        id: changelog
        run: |
          VERSION=${{ steps.version.outputs.version }}
          TODAY=$(date +%Y-%m-%d)
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD 2>/dev/null || echo "")
          if [ -n "$PREV_TAG" ]; then
            echo "Generating changelog from $PREV_TAG to HEAD"
            COMMITS=$(git log --pretty=format:"- %s" $PREV_TAG..HEAD | grep -vE '^- (docs|ci|chore):')
          else
            echo "No previous tag found, including recent commits"
            COMMITS=$(git log --pretty=format:"- %s" HEAD~10..HEAD 2>/dev/null || git log --pretty=format:"- %s" | grep -vE '^- (docs|ci|chore):')
          fi
          # Ensure we have at least something for the changelog
          if [ -z "$COMMITS" ]; then
            COMMITS="- Maintenance release"
          fi
          echo "$COMMITS" > changelog.txt
          cat > new_entry.txt << 'ENTRY_EOF'
          ## [$VERSION] - $TODAY

          ### Changed
          ENTRY_EOF
          sed -i "s/\$VERSION/$VERSION/g; s/\$TODAY/$TODAY/g" new_entry.txt
          echo "$COMMITS" >> new_entry.txt
          head -n 7 CHANGELOG.md > CHANGELOG.tmp
          echo "" >> CHANGELOG.tmp
          cat new_entry.txt >> CHANGELOG.tmp
          tail -n +8 CHANGELOG.md >> CHANGELOG.tmp
          mv CHANGELOG.tmp CHANGELOG.md
          rm new_entry.txt

      - name: Commit version bump and create tag
        run: |
          VERSION=${{ steps.version.outputs.version }}
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md module.json
          git commit -m "release: ${VERSION}" || echo "No changes to commit"
          git tag -a "${VERSION}" -m "Release ${VERSION}"
          git push origin main
          git push origin "${VERSION}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: "v${{ steps.version.outputs.version }}"
          body_path: changelog.txt
          files: |
            module.json
            ${{ env.MODULE_ID }}.zip
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish to Foundry VTT
        env:
          FVTT_TOKEN: ${{ secrets.FOUNDRY_RELEASE_TOKEN }}
        run: |
          OUTPUT=$(npx @ghost-fvtt/foundry-publish \
            --manifestPath module.json \
            --manifestURL "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.version }}/module.json" 2>&1) || {
            if echo "$OUTPUT" | grep -q "already exists"; then
              echo "Version already published to Foundry VTT, skipping"
              exit 0
            else
              echo "$OUTPUT"
              exit 1
            fi
          }

      - name: Announce on Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -z "$DISCORD_WEBHOOK_URL" ]; then
            echo "Discord webhook not configured, skipping announcement"
            exit 0
          fi
          VERSION=${{ steps.version.outputs.version }}
          REPO_URL="https://github.com/${{ github.repository }}"
          RELEASE_URL="${REPO_URL}/releases/tag/${VERSION}"
          # Discord field value limit is 1024 chars - truncate if needed but inform reader
          TOTAL_LINES=$(wc -l < changelog.txt)
          MAX_LINES=15
          if [ "$TOTAL_LINES" -gt "$MAX_LINES" ]; then
            REMAINING=$((TOTAL_LINES - MAX_LINES))
            CHANGELOG=$(head -$MAX_LINES changelog.txt)
            CHANGELOG="${CHANGELOG}"$'\n'"... and ${REMAINING} more. [See full release notes](${RELEASE_URL})"
          else
            CHANGELOG=$(cat changelog.txt)
          fi
          # Ensure we don't exceed Discord's 1024 char limit
          if [ ${#CHANGELOG} -ge 1000 ]; then
            CHANGELOG=$(echo "$CHANGELOG" | cut -c1-950)
            CHANGELOG="${CHANGELOG}..."$'\n'"[See full release notes](${RELEASE_URL})"
          fi

          # Build JSON payload with proper escaping using jq
          PAYLOAD=$(jq -n \
            --arg title "Simulacrum v${VERSION} Released!" \
            --arg url "$RELEASE_URL" \
            --arg desc "A new version of Simulacrum: AI Campaign Copilot is now available!" \
            --arg changes "$CHANGELOG" \
            --arg install "Update from Foundry VTT or [GitHub](${RELEASE_URL})" \
            '{
              embeds: [{
                title: $title,
                url: $url,
                color: 14206924,
                description: $desc,
                fields: [
                  {name: "Changes", value: $changes},
                  {name: "Install", value: $install}
                ],
                footer: {text: "Simulacrum: AI Campaign Copilot"}
              }]
            }')

          echo "Payload: $PAYLOAD"
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -H "Content-Type: application/json" -X POST -d "$PAYLOAD" "$DISCORD_WEBHOOK_URL")
          echo "Response: $RESPONSE"
